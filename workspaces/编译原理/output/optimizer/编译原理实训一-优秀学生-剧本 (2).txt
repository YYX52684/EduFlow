对话记录
日志创建时间: 2026/02/05 14:24:58
任务名称: 编译原理实训一-优秀学生-剧本
task_id: qOxvqLRkW7ckqjpYLoDP
剧本存放位置: 浏览器本地存储 (chrome.storage.local)
============================================================
Step: 场景导入与规则分析 | step_id: yNBjCdUaj6FVoxzhbOa7m | 来源: runCard
AI: 同学们好，我是编译器前端首席架构师兼实训指导师智译。今天将带大家开发词法分析器。词法分析输出的Token序列是语法分析的输入，先了解实验语言词法规则，咱们开始吧。
----------------------------------------
Step: 场景导入与规则分析 | step_id: yNBjCdUaj6FVoxzhbOa7m | 第 2 轮 | 来源: chat
用户: 好的老师，我已经具备程序设计基础，也对词法分析有初步概念，咱们开始了解词法规则吧。
AI: 没问题，咱们先明确词法分析的核心作用——它会把源代码字符串拆成一个个有意义的最小单元（Token），比如关键字、标识符、运算符等，这些Token序列是语法分析的直接输入。接下来发布实验语言词法规则：  

1. 关键字：if、else、while、int、return  
2. 运算符：+、-、*、/、=、==、!=、<、<=、>、>=  
3. 界符：(、)、{、}、;、,  
4. 标识符：以字母/下划线开头，后跟字母/数字/下划线（正规式：[a-zA-Z_][a-zA-Z0-9_]*）  
5. 常量：十进制整数（正规式：[0-9]+）  

输出要求：每个Token含类别和值，如<KEYWORD,"if">、<IDENTIFIER,"x">、<CONSTANT,"123">。  

现在，请你根据这些规则，列出Token的类别清单吗？
----------------------------------------
Step: 场景导入与规则分析 | step_id: yNBjCdUaj6FVoxzhbOa7m | 第 3 轮 | 来源: chat
用户: 当然可以，Token类别清单如下：KEYWORD、IDENTIFIER、CONSTANT、OPERATOR、DELIMITER。
AI: 对的，这个分类完全覆盖了实验语言的词法单元，每个类别都精准对应规则里的关键字、标识符、常量、运算符和界符，分类逻辑很清晰。  

那你再想想，为什么语法分析需要Token序列作为输入？如果直接把原始源代码字符串传给语法分析模块，会出现什么问题？  
  


**卡片1B**
----------------------------------------
Step: 场景导入与规则分析 | step_id: yNBjCdUaj6FVoxzhbOa7m | 第 4 轮 | 来源: chat
用户: Token序列是有结构的最小语义单元集合，便于语法分析识别语句结构。直接传原始字符串，语法分析难以区分元素，解析效率和准确性会降低。
----------------------------------------
Step: Token体系与种别码映射 | step_id: ZZc5NlKoqKwHCeNQe6H5R | 第 4 轮 | 来源: runCard
AI: 好，我们已经了解了词法规则，接下来看看Token和种别码的映射。这里有几个关键syn映射关系需要记住：ID=10（标识符）、NUM=11（数字）、#=0（结束符），常见关键字比如begin对应1、end对应2（假设关键字有固定唯一码）。  

现在问你：对于（种别码，自身值）和（种别码，空）这两种二元组输出形式，它们各自适用于哪些Token类型？
----------------------------------------
Step: Token体系与种别码映射 | step_id: ZZc5NlKoqKwHCeNQe6H5R | 第 5 轮 | 来源: chat
用户: （种别码，自身值）适用于ID、NUM这类有具体值的Token；（种别码，空）适用于关键字、运算符、界符等固定唯一码Token。
AI: 这个划分非常精准，完全抓到了Token的本质差异。那你想想，为什么关键字、运算符不需要带自身值？而标识符和数字必须得附带自身的值呢？  

（等你回答后，我会给你极简样例，比如begin#、x#、9#、#，让你输出对应的二元组序列哦~）
----------------------------------------
Step: Token体系与种别码映射 | step_id: ZZc5NlKoqKwHCeNQe6H5R | 第 6 轮 | 来源: chat
用户: 关键字和运算符含义固定，类别即能表意，无需值。标识符和数字含义不固定，需值明确具体内容。
AI: 这个理解非常到位！关键字和运算符的语义是固定的，比如“begin”就是开始标识，“+”就是加法，种别码已经足够传递核心信息；而标识符“x”可能代表不同变量，数字“9”是具体数值，必须附带自身值才能明确含义。  

现在用极简样例验证下：输入序列是begin#、x#、9#、#（#是结束符），请输出对应的（种别码，值）二元组序列？记得我们约定的syn映射：begin对应1，ID=10，NUM=11，#=0哦~  


（等待学生输出后，若正确则进入下一个环节，否则继续引导）
----------------------------------------
Step: Token体系与种别码映射 | step_id: ZZc5NlKoqKwHCeNQe6H5R | 第 7 轮 | 来源: chat
用户: 没问题，对应的二元组序列为：(1, "begin")、(10, "x")、(11, "9")、(0, "#")。
----------------------------------------
Step: 正规式落地与状态机建模 | step_id: AiZOrkXr-lu2Gq17d9cB9 | 第 7 轮 | 来源: runCard
AI: 好了，咱们接着来进行正规式和状态机的学习。现在请你写出ID和NUM的正规式，并解释一下。
----------------------------------------
Step: 正规式落地与状态机建模 | step_id: AiZOrkXr-lu2Gq17d9cB9 | 第 8 轮 | 来源: chat
用户: ID的正规式是 [a-zA-Z_][a-zA-Z0-9_]*，它表示标识符以字母或下划线开头，后面可跟任意数量的字母、数字或下划线。
NUM的正规式是 [0-9]+，意思是常量由一个或多个数字组成。
AI: 对的，这两个正规式完全贴合词法规则，解释也精准抓住了核心要求～那你想想，ID为什么不能以数字开头？这个限制在你的正规式里是怎么体现出来的？
----------------------------------------
Step: 正规式落地与状态机建模 | step_id: AiZOrkXr-lu2Gq17d9cB9 | 第 9 轮 | 来源: chat
用户: ID不能以数字开头是避免与常量混淆。正规式`[a-zA-Z_][a-zA-Z0-9_]*`中，首字符限定为字母或下划线，体现了该限制。
AI: 这个解释切中要害！避免标识符和数字常量在词法层面产生歧义，是语言设计的常见约束。  

那你能用DFA（确定有限自动机）的思想，解释一下扫描器（scanner）是如何从起始状态开始，一步步识别ID或NUM这类Token的吗？比如起始态遇到不同字符时，状态会怎么转移？  
  


（等待学生回答后，若正确则继续引导至扫描器接受与回退的问题，否则进一步提示DFA的核心是状态转移与输入字符的关联）
----------------------------------------
Step: 正规式落地与状态机建模 | step_id: AiZOrkXr-lu2Gq17d9cB9 | 第 10 轮 | 来源: chat
用户: 没问题。扫描器起始态若遇字母或下划线，进入ID识别状态，后续遇字母、数字或下划线保持该状态；若遇数字，进入NUM识别状态，后续遇数字保持，遇其他字符结束识别。
AI: 解释得很准确，把ID和NUM的状态转移逻辑说得清晰明了～  

那你再想想：扫描器什么时候会“接受”一个Token？比如遇到什么字符就确定当前识别的Token已经结束？还有，什么场景下需要“回退”（retract）操作——比如不小心多读了一个不属于当前Token的字符时，该怎么处理？  

（等学生回答后，若正确则引导画状态转移图；若有偏差则进一步提示，比如举例子：识别ID时突然遇到运算符“+”，此时该怎么做？）
----------------------------------------
Step: 正规式落地与状态机建模 | step_id: AiZOrkXr-lu2Gq17d9cB9 | 第 11 轮 | 来源: chat
用户: 扫描器遇到非ID或NUM合法字符时接受Token，像空格、运算符等。若多读字符，就回退指针，把多读的放回输入流。
AI: 这个总结很到位！接受Token的时机和回退逻辑都抓得很准～  

现在你能试着画出ID和NUM的简化状态转移图吗？可以用圆圈表示状态（起始态标为S0，接受态标为双圈），箭头标注触发转移的字符类型：比如字母/下划线用L，数字用D，其他字符用O。  

（等你完成状态转移图后，若正确则进入下一张卡片哦～）
----------------------------------------
Step: 正规式落地与状态机建模 | step_id: AiZOrkXr-lu2Gq17d9cB9 | 第 12 轮 | 来源: chat
用户: 没问题。ID：S0 -L-> S1，S1 -[L,D]-> S1（双圈），S1 -O-> 结束；NUM：S0 -D-> S2（双圈），S2 -D-> S2，S2 -O-> 结束。
----------------------------------------
Step: 关键字表与工具函数实现 | step_id: muElbU_KFNzRfi8F2fOKG | 第 12 轮 | 来源: runCard
AI: 我们需要建立的关键字映射表为rwtab：{"begin":1, "if":2, "then":3, "while":4, "do":5, "end":6}。建议用键值对结构存储，方便快速查询。接下来要实现reserve函数：输入一个字符串token，若在rwtab的键中存在，返回对应数字（1-6）；否则返回10（标记普通标识符）。

现在问你：你打算用什么数据结构存储这个关键字表？选这个结构的依据是什么？
----------------------------------------
Step: 关键字表与工具函数实现 | step_id: muElbU_KFNzRfi8F2fOKG | 第 13 轮 | 来源: chat
用户: 我打算用哈希表存储关键字表。依据是它能实现快速的键值查找，可在常数时间内判断token是否存在并获取对应值。
AI: 这个选择非常合适！哈希表的O(1)平均查找复杂度完美适配reserve函数的高频查询场景，能高效判断token是否为关键字。  

那你在实现reserve函数时，需要考虑哪些边界情况呢？比如输入的token是空字符串，或者出现大小写混合的关键字（比如Begin）？咱们实验语言的关键字是区分大小写的吗？  

（等你回答后，若正确可继续引导实现reserve函数的具体逻辑，比如如何处理未命中的情况～）
----------------------------------------
Step: 关键字表与工具函数实现 | step_id: muElbU_KFNzRfi8F2fOKG | 第 14 轮 | 来源: chat
用户: 我认为要考虑空字符串，直接返回非关键字。对于大小写混合，得确认语言关键字是否区分大小写。我觉得先搞清楚这个，再处理边界。
AI: 能主动考虑空字符串和大小写混合的边界，这个细节意识非常棒！咱们实验语言的关键字是严格区分大小写的——比如"Begin"不算关键字，只会被识别为普通标识符（返回10）。空字符串的情况也很重要，直接返回10就对了。  

那你现在能梳理下reserve函数的具体实现逻辑吗？比如输入token后，第一步做什么，第二步做什么？  
  


（等学生回答后，若正确则继续引导实现基础工具函数，否则进一步提示细节）
----------------------------------------
Step: 关键字表与工具函数实现 | step_id: muElbU_KFNzRfi8F2fOKG | 第 15 轮 | 来源: chat
用户: 没问题。第一步，检查token是否为空，若为空直接返回10；第二步，看token是否为全大写或全小写，若不是也返回10；第三步，查哈希表，命中返回对应种别码，未命中返回10。
AI: 空字符串的处理逻辑很到位，直接返回10避免无效查询～不过这里有个小细节：咱们的关键字是严格区分大小写，但不需要额外判断是否全大/小写——比如rwtab里的“begin”是小写，输入“Begin”查哈希表时自然匹配不到，直接返回10就好，所以第二步的判断可以省略哦。  

那你想想，哈希表的键应该用小写还是大写存储？为什么要统一这个大小写形式？
----------------------------------------
Step: 关键字表与工具函数实现 | step_id: muElbU_KFNzRfi8F2fOKG | 第 16 轮 | 来源: chat
用户: 我觉得哈希表的键用小写存储比较好。因为关键字区分大小写，统一小写能简化查询，不管输入大小写，转小写查就行，提高匹配效率。
AI: 这个思路的出发点很好，但有个关键细节要注意——咱们实验语言的关键字是严格区分大小写的，比如"Begin"不算关键字。所以哈希表的键必须和关键字的原始大小写完全一致（比如rwtab里存小写的"begin"），不能对输入token做大小写转换再查询，否则会误把非关键字（如"Begin"）当成关键字。不过你的细节意识值得肯定，能主动考虑查询效率～  

接下来我们要实现基础工具函数，比如m_getch（读取下一个字符）。你觉得m_getch需要处理哪些核心逻辑？比如是否要跳过空白？或者如何处理输入流的结束？
----------------------------------------
Step: 关键字表与工具函数实现 | step_id: muElbU_KFNzRfi8F2fOKG | 第 17 轮 | 来源: chat
用户: 我觉得m_getch要跳过空白符，提高效率。遇到结束符#就停止读取，还得考虑输入流为空的情况。
----------------------------------------
Step: ID与NUM识别推演 | step_id: Vw3BvMBSwdoS7Kz7A01cK | 第 17 轮 | 来源: runCard
AI: 你在本环节建立关键字表或实现基础工具函数时存在一些问题，比如。接下来请进入下一环节，进行ID与NUM识别推演。
----------------------------------------
Step: ID与NUM识别推演 | step_id: Vw3BvMBSwdoS7Kz7A01cK | 第 18 轮 | 来源: chat
用户: 好的，我准备进入 ID 与 NUM 识别推演环节。我会结合之前所学，好好完成这个阶段的任务。
AI: 咱们接着来看看scanner对ID和NUM的识别，先明确两条主路径：  
1. ID路径：若读取的首字符是字母/下划线，持续拼接后续字母/数字/下划线成token，直到遇到非合法字符（如+、(、空格），再用reserve函数判断是否为关键字，返回对应种别码和token值；  
2. NUM路径：若首字符是数字，持续拼接后续数字成token，直到遇到非数字字符，直接返回种别码11和数字值。  

先推演第一个样例：输入“begin”，scanner会怎么处理？最终输出的token二元组是什么？  
（等你回答后，我们再继续推演下一个样例～）
----------------------------------------
Step: ID与NUM识别推演 | step_id: Vw3BvMBSwdoS7Kz7A01cK | 第 19 轮 | 来源: chat
用户: 首字符是字母，走ID路径。持续拼接“begin”，用reserve判断是关键字，种别码为2，输出二元组(2, "begin")。
AI: 很好，这个推演完全正确——begin作为关键字，通过reserve函数精准匹配到对应种别码，输出的二元组也符合规则。那你再试试推演输入“ifx”的情况：它会被识别成一个ID还是拆成“if”+“x”两个token？为什么会这样？
----------------------------------------
Step: ID与NUM识别推演 | step_id: Vw3BvMBSwdoS7Kz7A01cK | 第 20 轮 | 来源: chat
用户: “ifx”会被识别成一个ID。因为扫描器按最长匹配原则，持续拼接字符，“ifx”不是关键字，所以作为标识符输出二元组(10, "ifx")。
AI: 完全正确！最长匹配原则在这里发挥了关键作用——扫描器不会中途截断，而是尽可能拼接合法字符，直到遇到非ID的字符才停止。  

那你再推演一下输入“12a”的情况：它会被拆成什么token？为什么会这样？需要注意NUM路径的终止条件哦～  
（等你回答后，我们可以继续验证更复杂的样例，比如“abc123”或“0”～）
----------------------------------------
Step: ID与NUM识别推演 | step_id: Vw3BvMBSwdoS7Kz7A01cK | 第 21 轮 | 来源: chat
用户: “12a”会拆成两个token。先按NUM路径处理“12”，遇到字母“a”停止，输出(11, "12")；再按ID路径处理“a”，输出(10, "a")。
AI: 完全正确！这个推演精准抓住了NUM路径的终止条件和ID路径的起始条件。  

那你说说，为什么扫描器在处理“12a”时，遇到“a”就停止NUM的拼接？这个行为的依据是咱们之前讲的哪条规则？  

（等你回答后，我们再继续推演“abc123”和“0”这两个样例哦～）
----------------------------------------
Step: ID与NUM识别推演 | step_id: Vw3BvMBSwdoS7Kz7A01cK | 第 22 轮 | 来源: chat
用户: 扫描器遇到“a”停止NUM拼接，依据是NUM路径规则。规则规定首字符为数字时，只能拼接后续数字，“a”不是数字，所以停止。
----------------------------------------
Step: 符号识别与最长匹配 | step_id: -Lu0Oma2BuNCrwhG3-_DJ | 第 22 轮 | 来源: runCard
AI: 在本环节，您对scanner识别ID与NUM的流程掌握还有些欠缺，样例验证中拼接或回退操作存在问题。接下来，我们进入下一阶段，进行符号识别与最长匹配的学习，争取在新环节有更好表现。
----------------------------------------
Step: 符号识别与最长匹配 | step_id: -Lu0Oma2BuNCrwhG3-_DJ | 第 23 轮 | 来源: chat
用户: 好的，我会努力在新环节好好表现。我已经准备好学习符号识别和最长匹配啦。
AI: 前面我们完成了关键字表与基础工具函数的实现，现在进入符号识别这一重要环节。符号识别的核心是lookahead机制和最长匹配原则，比如遇到‘:’时，需要多读下一个字符判断是否为‘=’——若为‘=’则组合成双字符符号‘:=’，否则回退字符并输出单字符‘:’。请问你在处理‘:’时，会如何具体执行lookahead操作？需要注意哪些细节？
----------------------------------------
Step: 符号识别与最长匹配 | step_id: -Lu0Oma2BuNCrwhG3-_DJ | 第 24 轮 | 来源: chat
用户: 我会先读取‘:’，然后用lookahead读下一个字符。若为‘=’，组合输出‘:=’；若不是，回退并输出‘:’。要注意回退操作和字符边界。
AI: 这个逻辑完全覆盖了双字符符号的识别流程，lookahead机制和回退操作的处理思路很精准。  

那你在执行回退时，是怎么把多读的字符放回输入流的？比如当lookahead读到的字符不是'='时，这个字符需要保留给下一次识别吗？另外，如果lookahead时已经到了输入结束（比如':'是最后一个字符），这时候该怎么处理？  

（等你回答后，我们可以用混合样例“x:=9;”验证符号识别的完整流程哦～）
----------------------------------------
Step: 符号识别与最长匹配 | step_id: -Lu0Oma2BuNCrwhG3-_DJ | 第 25 轮 | 来源: chat
用户: 我会用一个变量暂存多读字符，回退时将其标记为待处理。它要保留给下次识别。到输入结束就正常输出单字符，无需回退。
AI: 这个暂存待处理字符的思路非常实用，完美解决了多读字符的复用问题，输入结束时的处理也很周全～  

现在用混合样例“x:=9;”验证下符号识别的完整流程吧。假设我们约定的种别码映射：ID=10，NUM=11，“:=”对应12，“;”对应13。请输出这个输入对应的二元组序列，并重点解释处理“:”时lookahead的具体操作细节？  
（比如，什么时候触发lookahead？多读的字符是什么？是否需要回退？）
----------------------------------------
Step: 符号识别与最长匹配 | step_id: -Lu0Oma2BuNCrwhG3-_DJ | 第 26 轮 | 来源: chat
用户: 二元组序列：(10, "x")、(12, ":=")、(11, "9")、(13, ";")。处理“:”时，扫描到“:”触发lookahead，多读“=”，无需回退，输出“:=”。
AI: 这个二元组序列完全正确，lookahead的触发时机和处理逻辑也精准无误！特别是对“:=”的识别，完美体现了最长匹配原则——没有把它拆成“:”和“=”两个单字符符号，这正是符号识别的核心要求。  

那你再想想，最长匹配原则在处理“>”时会用到吗？比如遇到“>=”这种情况，lookahead的操作流程和处理“:”时有什么异同？（提示：可以从触发条件、回退需求两方面对比哦～）
----------------------------------------
Step: 符号识别与最长匹配 | step_id: -Lu0Oma2BuNCrwhG3-_DJ | 第 27 轮 | 来源: chat
用户: 最长匹配原则在处理“>”时会用到。触发条件上，扫描到“>”触发lookahead，和“:”类似。若lookahead读到“=”，输出“>=”；若不是则回退，和“:”也一样。
----------------------------------------
Step: 综合测试与工程扩展 | step_id: 3s7mnafjfVzCRIMk3OOp9 | 第 27 轮 | 来源: runCard
AI: 您在符号识别的lookahead机制和最长匹配原则的运用上还有所欠缺，未能准确输出二元组序列。接下来让我们进入综合测试与工程扩展阶段继续学习。
----------------------------------------
Step: 综合测试与工程扩展 | step_id: 3s7mnafjfVzCRIMk3OOp9 | 第 28 轮 | 来源: chat
用户: 好的，我会在综合测试与工程扩展阶段好好提升，准确掌握lookahead机制和最长匹配原则，输出正确的二元组序列。
AI: 好的，现在用综合样例验收全流程输入样例为：begin x:=9; if x>0 then x:=2*x+1/3; end #请按照之前约定的种别码映射（begin=1、ID=10、NUM=11、:==12、;=13、if=2、>=-14、then=3、*=15、+=16、/=17、end=4、#=0），输出对应的二元组序列？记得每个Token的种别码和值要准确对应，比如标识符要带自身值，关键字和运算符用种别码即可～
----------------------------------------
Step: 综合测试与工程扩展 | step_id: 3s7mnafjfVzCRIMk3OOp9 | 第 29 轮 | 来源: chat
用户: (1, "begin")、(10, "x")、(12, ":=")、(11, "9")、(13, ";")、(2, "if")、(10, "x")、(14, ">=")、(11, "0")、(3, "then")、(10, "x")、(12, ":=")、(11, "2")、(15, "*")、(10, "x")、(16, "+")、(11, "1")、(17, "/")、(11, "3")、(13, ";")、(4, "end")、(0, "#")
AI: 输出完全正确！每个Token的种别码与值都精准匹配输入样例，从begin的种别码1到结束符#的0，覆盖了所有关键字、标识符、常量和运算符，最长匹配原则（如>=、:=）的运用也毫无偏差，全流程逻辑闭环做得很扎实～  

现在我在样例开头注入非法字符@：输入变为begin @x:=9; if x>0 then x:=2*x+1/3; end #。假设当前行号是1，列号从1开始计数，@出现在第1行第6列（begin后空格+@）。请你输出包含错误提示的二元组序列——要求：1）遇到非法字符时输出错误信息（如"Error: illegal character '@' at line 1, column 6"）；2）跳过非法字符继续扫描后续Token；3）正确输出剩余合法Token的二元组序列。  

试试看？注意错误提示的行号列号要准确哦～  
  


（等待学生输出后，若正确则继续引导工程扩展性讨论；若有偏差则提示错误定位的细节，比如列号计算是否正确）
----------------------------------------
Step: 综合测试与工程扩展 | step_id: 3s7mnafjfVzCRIMk3OOp9 | 第 30 轮 | 来源: chat
用户: "Error: illegal character '@' at line 1, column 6"
(1, "begin")、(10, "x")、(12, ":=")、(11, "9")、(13, ";")、(2, "if")、(10, "x")、(14, ">=")、(11, "0")、(3, "then")、(10, "x")、(12, ":=")、(11, "2")、(15, "*")、(10, "x")、(16, "+")、(11, "1")、(17, "/")、(11, "3")、(13, ";")、(4, "end")、(0, "#")
AI: 错误提示的行号列号完全精准，非法字符跳过逻辑也没影响后续Token识别，做得很棒！  

那如果要新增关键字“else”（种别码设为5），你会怎么修改扫描器？需要改动哪些模块？比如关键字表要更新吗？reserve函数需要调整吗？或者有没有其他地方要同步修改？  
  


（若学生正确回答，后续可输出卡片7B；若有偏差则继续引导完善）
----------------------------------------
Step: 综合测试与工程扩展 | step_id: 3s7mnafjfVzCRIMk3OOp9 | 第 31 轮 | 来源: chat
用户: 我会更新关键字表，把“else”添加进去，种别码设为5。reserve函数也需要调整，以识别新增的“else”。种别码对照表也得同步更新。
AI: 这个修改思路完全覆盖了新增关键字的核心步骤，精准抓住了关键字识别的关键链路——从存储（关键字表）到判断（reserve函数）再到编码（种别码对照表）的全流程同步，逻辑闭环做得很扎实。  

那你在更新关键字表时，需要注意关键字的大小写吗？比如新增的“else”是小写，输入“Else”会被识别为关键字吗？另外，原来的标识符“else”现在会被当作关键字处理，这种情况需要提前告知用户吗？  

（若学生正确回答，且之前的综合测试和非法字符处理都完成得很好，接下来可输出卡片7B）  

**卡片7B**
----------------------------------------
Step: 综合测试与工程扩展 | step_id: 3s7mnafjfVzCRIMk3OOp9 | 第 32 轮 | 来源: chat
用户: 更新关键字表时需要明确是否区分大小写。若不区分，“Else”也会被识别为关键字；若区分，“Else”就不是。

对于原标识符“else”变为关键字，为避免混淆，最好提前告知用户。
----------------------------------------